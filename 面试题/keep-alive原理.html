<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>keep-alive原理</title>
  </head>
  <body>
    <!-- keep-alive原理 -->
    1.
    在动态组件切换时，保留组件状态（如表单输入、滚动位置、内部数据），避免重复创建带来的性能损耗。
    <!--  -->
    <script>
            // 1. 缓存机制
            class KeepAlive {
              constructor(max) {
                this.cache = new Map();
                this.keys = [];
                this.max = max || 10;
              }
              activate(vnode) {
                // 缓存组件
                this.cache.set(vnode.key, vnode);
              }
              deactivated(vnode) {
                // 删除缓存的组件
                this.cache.delete(vnode.key);
              }
              get(key) {
                if (this.cache.has(key)) {
                  // 移动到数组末尾
                  this.keys.splice(this.keys.indexOf(key), 1);
                  this.keys.push(key);
                  return this.cache.get(key);
                }
                return null;
                // 获取缓存的组件
              }
              set(key, vnode) {
                if (this.cache.has(key)) {
                  // 移动到数组末尾
                  this.keys.splice(this.keys.indexOf(key), 1);
                } else if (this.keys.length >= this.max) {
                  // LRU淘汰：删除最久未使用的
                  const oldestKey = this.keys.shift();
                  this.cache.delete(oldestKey);
                }
                this.keys.push(key);
              }
            }
      
    </script>
  </body>
</html>
